import archiver from "archiver"
import fs from "fs"
import path from "path"
import { v4 as uuidv4 } from "uuid"
import { fileURLToPath } from "url"

const __dirname = path.dirname(fileURLToPath(import.meta.url))

/**
 * Service for creating downloadable project packages
 */

export async function createProjectZip(generation, outputDir) {
  return new Promise(async (resolve, reject) => {
    try {
      const projectId = uuidv4()
      const zipPath = path.join(outputDir, `${projectId}.zip`)

      // Create output directory if it doesn't exist
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true })
      }

      const output = fs.createWriteStream(zipPath)
      const archive = archiver("zip", { zlib: { level: 9 } })

      output.on("close", () => {
        console.log(`[Package Service] ZIP created: ${zipPath} (${archive.pointer()} bytes)`)
        resolve({
          path: zipPath,
          filename: `${projectId}.zip`,
          size: archive.pointer(),
        })
      })

      archive.on("error", (error) => {
        console.error("[Package Service] Archive error:", error)
        reject(error)
      })

      archive.pipe(output)

      // Add files to archive
      if (generation.generatedCode && generation.generatedCode.files) {
        for (const file of generation.generatedCode.files) {
          const fileName = file.path || file.name
          archive.append(file.content, { name: fileName })
        }
      }

      // Add README
      const readme = `# Generated Project

Generated from: ${generation.prompt}
Type: ${generation.type}
Date: ${new Date().toLocaleString()}

## Getting Started

${generation.generatedCode?.startCommand || "See documentation for setup instructions"}

## Project Structure

${generation.generatedCode?.projectStructure || "N/A"}

---
Generated by AI Website Generator`

      archive.append(readme, { name: "README.md" })

      await archive.finalize()
    } catch (error) {
      console.error("[Package Service] Error:", error)
      reject(error)
    }
  })
}

export async function deleteProjectZip(zipPath) {
  return new Promise((resolve, reject) => {
    if (fs.existsSync(zipPath)) {
      fs.unlink(zipPath, (error) => {
        if (error) reject(error)
        else resolve()
      })
    } else {
      resolve()
    }
  })
}
